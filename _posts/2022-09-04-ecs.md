---
title: "ECS"
excerpt: "ECS pattern for react"

categories:
  - Architecture
tags:
  - [시작]

permalink: /categories/architecture/ecs-1

toc: true
toc_sticky: true

date: 2023-09-04
last_modified_at: 2023-09-04
---

## 왜

게임 개발할때마다 개체간의 관계 정립 및 렌더 방식을 손 가는대로 했다.

마침 React-Three-Fiber [미니플젝](/demo/jukebox/) 하며 다른 사례들을 조사하다가 ECS라는 패턴을 발견했다. 직관적이고 실용적인 패턴이라고 생각돼서 기본적인 내용들을 정리해 본다. ECS의 자세한 내용 및 패턴 철학은 공부하며 참고한 링크들을 아래에 걸어둘테니 꼭! 읽어보시길

## 그동안 내가 했던 방법들

부끄럽지만 적어봅니다.

### C++ / DirectX

3D / 2D 게임의 클라이언트 및 서버를 개발했던 시기였다. 엔진 이라고 부를만한 프레임워크가 없이 렌더 부분만 래핑해놓은 유틸성 라이브러리만 가지고 개발을 했다.

상속을 기반으로 개체 내에서 Update, Render 모두 진행하는 구조로 개발했으며 대략 아래와 같다.

### Unity

Unity는 기본적으로 GameObject를 생성을 하고 기대하는 동작들을 스크립트로 만들어 오브젝트에 할당하는 컴포넌트 방식을 따른다. 입출력, 움직임, 렌더등을 컴포넌트화 시킨다. 하나의 거대한 클래스가 존재하는게 아닌, 분리된 역할을 가진 컴포넌트들의 조합으로 복잡한행동(behaviour)을 하는 개체를 만드는것. 이 구조 내에서 개발자의 역량과 취향에 따라 다양한 패턴을 적용하게 되는것이다.

```mermaid
classDiagram
  class GameObject
  class Component
  class RigidBody
  class MonoBehaviour

  RigidBody --|> Component
  MonoBehaviour --|> Component
  GameObject --> Component: list
```

각 컴포넌트에서 각자 하고싶은 목적을 이루면된다. 행동 및 렌더도 컴포넌트로 구현되며 이 과정중 다른 컴포넌트 혹은 GameObject를 참조할 수 있다.

```c#

using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour {
    public float thrust;
    public Rigidbody rb;
    void Start() {
        rb = GetComponent<Rigidbody>();
    }
    void FixedUpdate() {
        rb.AddForce(transform.forward * thrust);
    }
}
```

### R3F(React Three Fiber)

React는 선언형 프로그래밍 라이브러리, Three는 그래픽 라이브러리이다. 두가지를 가지고 게임을 만들때 어떤식으로 사용하게 될까.

```jsx
<Canvas>
  <Scene>
    <Camera />
    <GameObjects>
      <Player name={"james"} weapons={weapons} />
      {otherPlayers}
      {enemies}
      <Fairy target={"james"} />
      <SomeEffect target={"james"} />
    </GameObjects>
  </Scene>
</Canvas>
```

Unity 처럼 캔바스에다가 오브젝트들을 나열해 놓게된다. 컴포넌트들은 상호 참조할 수 있고 부모 자식으로 놓일 수 있다. Fairy는 캐릭터를 따라다니는 요정이므로 다음처럼 구현할 수 있다고 본다. SomeEffect 도 비슷하다.

```jsx
const Fairy = ({ target }) => {
  const { findObjectByName } = useObjects();
  const targetObject = findObjectByName(target);

  // do some actions

  return <mesh position={targetObject.position}>...</mesh>;
};

const SomeEffect = ({ target }) => {
  const { findObjectByName } = useObjects();
  const targetObject = findObjectByName(target);

  return <mesh position={targetObject.position}>...</mesh>;
};
```

혹은 사용자의 path 를 props 로 넘겨받아 추적하게 할 수 있다.

```jsx
const Fairy = ({ paths }) => {
  ...
    useEffect(() => {
    const followPath = () => {
      if (path.length > 0) {
        const [newX, newY] = path[path.length - 1];
        setFairyX(newX);
        setFairyY(newY);
      }
    }});
  ...
};

```

### 종합해보자면

위의 방식 모두 각 객체마다 표현하고자 하는 데이터(상태, 목적), 그리고 행동을 직접 수행한다. 컴포넌트의 행위가 복잡해질 수록 코드 덩어리는 비대해지고 각 개체간의 커플링은 심화된다. 가령 위 리액트 예제에 총알이 추가된다고 생각해보자. 총알은 속력과 방향(값)을 가지고 적을 향해 날아간다(행위). 적에게 적중하면 적의 에너지는 감소하고 적은 비틀댄다.

```jsx
const Bullet = ({ speed, from, to }) => {
  const ref = useRef()

  useFrame((state, delta) => {
    ...
    ref.current.position = newPosition
    ...
  })
  return <mesh ref={ref}></mesh>;
};


// App.tsx
const [bullets, setBullets] = useState([])

useEffect(() => {
  const newBullet = <Bullet speed={1} from={shotFrom} to={to} />
  setBullets([...bullets, newBullet])
},[shotFrom, to])

useFrame(() => {
  ...
  // 적이 맞았는지 체크
})

```

## ECS(Entity Component System)

### 고민들

- 유지보수하기 쉬운 구조
- 객체간의 통신, 필요하지만 코드가 복잡해지는 주요 원인중 하나, 즉 객체는 독립된 개체이지만, 상호작용을 한다.
- OOP 에서는 캡슐화를 중요시하는 구조 (데이터 + 메소드)
- 메소드 구현의 수준과 가독성, 그리고 객체를 사용하는 방법에 대한 문제

### ECS 소개

### Unity's GameObject 와의 차이

game object 는 Component Pattern 의 구현(http://gameprogrammingpatterns.com/component.html)

### 상속 과의 비교

### 나의 질문

- 어떤 함수는 데이터가 될 수 있을까?

### ECS + R3F 를 활용한 게임 구조

### ECS for Web

## 참고링크

[https://www.youtube.com/watch?v=\_U9wRgQyy6s](https://www.youtube.com/watch?v=_U9wRgQyy6s)

[https://www.sebaslab.com/the-quest-for-maintainable-code-and-the-path-to-ecs/](https://www.sebaslab.com/the-quest-for-maintainable-code-and-the-path-to-ecs/)

[https://www.sebaslab.com/code-design-articles/](https://www.sebaslab.com/code-design-articles/)
